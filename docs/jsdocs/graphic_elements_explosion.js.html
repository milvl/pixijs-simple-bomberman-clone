<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: graphic_elements/explosion.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: graphic_elements/explosion.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as PIXI from 'pixi.js';
import { Arena } from './arena.js';
import { Entity } from './entity.js';
import { DURATIONS } from '/js/constants/durations.js';

const MODULE_NAME_PREFIX = 'explosion.js - ';

export class Explosion {
    #DURATION_MS_EXPLOSION = DURATIONS.MS_EXPLOSION;

    /**
     * Creates an explosion in the arena.
     * @param app {PIXI.Application} - The PIXI application.
     * @param arena {Arena} - The arena where the explosion will be spawned.
     * @param gridX {number} - The x coordinate in the grid.
     * @param gridY {number} - The y coordinate in the grid.
     * @param textures {Object} - The textures object.
     * @param scaleToWall {number} - The scale factor to apply to the explosion.
     */
    constructor(app, arena, texture, scaleToWall) {
        this.app = app;
        this.arena = arena;
        this.texture = texture;
        this.scaleToWall = scaleToWall;
        this._explosionInstances = [];
        this.time = 0;
        this._isFinished = false;
    }

    /**
     * Gets the explosion instances (graphics elements).
     * @returns {Array} The explosion instances.
     */
    get explosionInstances() {
        return this._explosionInstances;
    }

    /**
     * Gets if the explosion has finished.
     * @returns {boolean} If the explosion has finished.
     */
    get isFinished() {
        return this._isFinished;
    }

    /**
     * Redraws the explosion in the arena.
     */
    redraw() {
        this._explosionInstances.forEach(explosion => {
            explosion.redraw();
        });
    }

    /**
     * Spawns the explosion in the arena.
     * @param gridX {number} - The x coordinate in the grid.
     * @param gridY {number} - The y coordinate in the grid.
     * @throws {Error} - Invalid bomb detonation coordinates.
     */
    spawn(gridX, gridY) {
        // sanity check
        if (gridX &lt;= 0 || gridX >= this.arena.colsCount - 1 || gridY &lt;= 0 || gridY >= this.arena.rowsCount - 1) {
            console.error(MODULE_NAME_PREFIX, 'Invalid bomb detonation coordinates:', gridX, gridY);
            throw new Error('Invalid bomb detonation coordinates');
        }

        // explosion positions
        const {centerX, centerY} = {centerX: gridX, centerY: gridY};
        const {northX, northY} = {northX: gridX, northY: gridY - 1};
        const {southX, southY} = {southX: gridX, southY: gridY + 1};
        const {eastX, eastY} = {eastX: gridX + 1, eastY: gridY};
        const {westX, westY} = {westX: gridX - 1, westY: gridY};
        const spread = [{x: northX, y: northY}, {x: southX, y: southY}, {x: eastX, y: eastY}, {x: westX, y: westY}];

        const spawnCoords = [];
        
        // create explosion sprites (now with graphics
        // center
        let explosion = new ExplosionInstance(this.app, this.arena, this.texture, this.scaleToWall);
        spawnCoords.push(this.arena.gridToCanvas(centerX, centerY));

        this._explosionInstances.push(explosion);
        // all directions
        for (let dir of spread) {
            if (this.arena.grid[dir.y][dir.x].type === Arena.GRID_CELL_TYPE.EMPTY) {
                explosion = new ExplosionInstance(this.app, this.arena, this.texture, this.scaleToWall);
                spawnCoords.push(this.arena.gridToCanvas(dir.x, dir.y));
                this._explosionInstances.push(explosion);
            }
        }

        for (let i = 0; i &lt; this._explosionInstances.length; i++) {
            const { x, y } = spawnCoords[i];
            this._explosionInstances[i].spawn(x, y);
        }
    }

    /**
     * Updates the explosion in the arena.
     * @param updateData {object} - The update data.
     * @returns {object} The updated explosion data.
     */
    update(updateData) {
        const { deltaTimeMS: deltaTimeMS } = updateData;
        this.time += deltaTimeMS;

        // explosion finished
        if (this.time >= this.#DURATION_MS_EXPLOSION) {
            this._explosionInstances.forEach(explosion => {
                explosion.remove();
            });
            this._explosionInstances = [];
            this._isFinished = true;
        }

        const res = {
            time: this.time,
        }
        return res;
    }

    /**
     * Removes the explosion from the arena. 
     * This is useful when the arena is reset.
     */
    remove() {
        this._explosionInstances.forEach(explosion => {
            explosion.remove();
        });
        this._explosionInstances = [];
    }
}

class ExplosionInstance extends Entity {
    /**
     * Represents an explosion in the arena.
     * @param app {PIXI.Application} - The PIXI application.
     * @param arena {Arena} - The arena where the explosion will be spawned.
     * @param texture {PIXI.Sprite} - The graphic element that represents the explosion.
     * @param scaleToWall {number} - The scale factor to apply to the explosion.
     */
    constructor(app, arena, texture, scaleToWall) {
        super(app, arena, texture, scaleToWall);
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Arena.html">Arena</a></li><li><a href="Bomb_Bomb.html">Bomb</a></li><li><a href="BreakableWall_BreakableWall.html">BreakableWall</a></li><li><a href="EndGameDrawingManager.html">EndGameDrawingManager</a></li><li><a href="Enemy.html">Enemy</a></li><li><a href="Entity.html">Entity</a></li><li><a href="Explosion_Explosion.html">Explosion</a></li><li><a href="ExplosionInstance.html">ExplosionInstance</a></li><li><a href="Game.html">Game</a></li><li><a href="GameSessionManager.html">GameSessionManager</a></li><li><a href="GameSessionState.html">GameSessionState</a></li><li><a href="GameState.html">GameState</a></li><li><a href="MainMenuDrawingManager.html">MainMenuDrawingManager</a></li><li><a href="Player_Player.html">Player</a></li><li><a href="SettingsDrawingManager.html">SettingsDrawingManager</a></li><li><a href="SoundManager.html">SoundManager</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getBespokeRectText">getBespokeRectText</a></li><li><a href="global.html#getFontSize">getFontSize</a></li><li><a href="global.html#getProperDimensions">getProperDimensions</a></li><li><a href="global.html#getStringWithSafeMargin">getStringWithSafeMargin</a></li><li><a href="global.html#keyboard">keyboard</a></li><li><a href="global.html#loadAssetsManifest">loadAssetsManifest</a></li><li><a href="global.html#loadTextures">loadTextures</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#parseTime">parseTime</a></li><li><a href="global.html#PIXI_INIT_CONFIG">PIXI_INIT_CONFIG</a></li><li><a href="global.html#prepareAssets">prepareAssets</a></li><li><a href="global.html#prepareGameAssets">prepareGameAssets</a></li><li><a href="global.html#resizeCanvas">resizeCanvas</a></li><li><a href="global.html#setup">setup</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sun Jun 09 2024 19:21:47 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
