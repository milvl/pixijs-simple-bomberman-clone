<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: graphic_elements/arena.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: graphic_elements/arena.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as PIXI from 'pixi.js';
import { HEX_COLOR_CODES } from '../constants/color_codes.js';

const MODULE_NAME_PREFIX = 'arena.js - ';

/**
 * Represents a game session.
 */
export class Arena {
    static GRID_CELL_TYPE = {
        WALL: 1,
        EMPTY: 0,
    };

    /**
     * Creates a new arena with walls and empty spaces.
     * @param {PIXI.Application} app - The PIXI application.
     * @param {Object} textures - The textures object.
     * @param {Number} rowsCount - The number of rows in the arena.
     * @param {Number} colsCount - The number of columns in the arena.
     * @param {Number} [scaleWidthArenaToScreen=1] - The scale factor for width.
     * @param {Number} [scaleHeightArenaToScreen=1] - The scale factor for height.
     */
    constructor(app, textures, rowsCount, colsCount, scaleWidthArenaToScreen = 1, scaleHeightArenaToScreen = 1) {
        this.app = app;
        this.textures = textures;
        this.rowsCount = rowsCount;
        this.colsCount = colsCount;
        this.scaleWidthArenaToScreen = scaleWidthArenaToScreen;
        this.scaleHeightArenaToScreen = scaleHeightArenaToScreen;
        this.grid = this.#createGrid(rowsCount, colsCount);
        this.wallWidth = null;
        this.wallHeight = null;
        this.wallsElements = [];
        this.freeSpaceElements = [];
    }

    /**
     * Creates a grid with walls and empty spaces.
     * @param {Number} rowsCount - The number of rows in the grid.
     * @param {Number} colsCount - The number of columns in the grid.
     * @returns {Array} The grid.
    */
    #createGrid(rowsCount, colsCount) {
        const grid = [];
        for (let rowIndex = 0; rowIndex &lt; rowsCount; rowIndex++) {
            const row = [];
            for (let colIndex = 0; colIndex &lt; colsCount; colIndex++) {
                if (rowIndex === 0 || rowIndex === (rowsCount - 1) || colIndex === 0 || colIndex === (colsCount - 1)) {
                    row.push({type: Arena.GRID_CELL_TYPE.WALL, elem: null}); // outer walls
                } else if ((rowIndex % 2) === 0 &amp;&amp; (colIndex % 2) === 0) {
                    row.push({type: Arena.GRID_CELL_TYPE.WALL, elem: null}); // inner walls
                } else {
                    row.push({type: Arena.GRID_CELL_TYPE.EMPTY, elem: null}); // empty space
                }
            }
            grid.push(row);
        }
        return grid;
    }

    /**
     * Converts grid coordinates to canvas coordinates.
     * @param {Number} gridX - The x-coordinate on the grid.
     * @param {Number} gridY - The y-coordinate on the grid.
     * @returns {Object} The canvas coordinates.
     */
    gridToCanvas(gridX, gridY) {
        const { width: screenWidth, height: screenHeight } = this.app.screen;
        let cellWidth = screenWidth * this.scaleWidthArenaToScreen / this.colsCount;
        let cellHeight = screenHeight * this.scaleHeightArenaToScreen / this.rowsCount;
        let canvasX = gridX * cellWidth;
        let y_offset = (screenHeight - (cellHeight * this.rowsCount));
        let canvasY = y_offset + (gridY * cellHeight);
        return { x: canvasX, y: canvasY, cellWidth: cellWidth, cellHeight: cellHeight };
    }

    /**
     * Converts canvas coordinates to grid coordinates.
     * @param {Number} canvasX - The x-coordinate on the canvas.
     * @param {Number} canvasY - The y-coordinate on the canvas.
     * @returns {Object} The grid coordinates.
     */
    canvasToGrid(canvasX, canvasY) {
        const { width: screenWidth, height: screenHeight } = this.app.screen;
        let cellWidth = screenWidth * this.scaleWidthArenaToScreen / this.colsCount;
        let cellHeight = screenHeight * this.scaleHeightArenaToScreen / this.rowsCount;
        let gridX = Math.round(canvasX / cellWidth);
        let y_offset = (screenHeight - (cellHeight * this.rowsCount));
        let gridY = Math.round((canvasY - y_offset) / cellHeight);
        return { x: gridX, y: gridY };
    }

    /**
      * Checks if an element will collide with a wall 
      * based on its velocity and position.
      * Information returned in separate horizontal and vertical flags 
      * to allow sliding along walls.
      * @param {PIXI.Sprite} elem - The element to check for collision.
      * @param {Number} [deltaX=0] - The change in x-coordinate.
      * @param {Number} [deltaY=0] - The change in y-coordinate.
      * @param {Function} checkCollisionFn - The collision detection function.
      * @returns {Object} An object with the horizontal and vertical collision flags.
      */
    checkWallCollision(elem, deltaX = 0, deltaY = 0, checkCollisionFn) {
        let willCollideHorizontal = false;
        let willCollideVertical = false;
        const elemBounds = elem.getBounds();
        for (let rowIndex = 0; rowIndex &lt; this.rowsCount; rowIndex++) {
            for (let colIndex = 0; colIndex &lt; this.colsCount; colIndex++) {
                if (this.grid[rowIndex][colIndex].type !== Arena.GRID_CELL_TYPE.WALL) {
                    continue;
                }
                const wall = this.grid[rowIndex][colIndex].elem;
                const wallBounds = wall.getBounds();

                if (!willCollideHorizontal) {
                    willCollideHorizontal = checkCollisionFn(elemBounds.minX, elemBounds.minY, elemBounds.width, elemBounds.height, wallBounds.x, wallBounds.y, wallBounds.width, wallBounds.height, deltaX);
                }
                if (!willCollideVertical) {
                    willCollideVertical = checkCollisionFn(elemBounds.minX, elemBounds.minY, elemBounds.width, elemBounds.height, wallBounds.x, wallBounds.y, wallBounds.width, wallBounds.height, 0, deltaY);
                }
                if (willCollideHorizontal &amp;&amp; willCollideVertical) {
                    break;
                }
            }
        }
        return {horizontal: willCollideHorizontal, vertical: willCollideVertical};
    }

    /**
     * Returns random empty space coordinates.
     * @returns {Object} The random empty space coordinates.
     */
    randomEmptySpace() {
        let rowIndex = Math.floor(Math.random() * this.rowsCount);
        let colIndex = Math.floor(Math.random() * this.colsCount);
        while (this.grid[rowIndex][colIndex].type === Arena.GRID_CELL_TYPE.WALL) {
            rowIndex = Math.floor(Math.random() * this.rowsCount);
            colIndex = Math.floor(Math.random() * this.colsCount);
        }
        
        const { x: xCoord, y: yCoord } = this.gridToCanvas(colIndex, rowIndex)
        return { x: xCoord, y: yCoord };
    }

    /**
     * Draws the arena on the screen.
     */
    draw() {
        const { width: screenWidth, height: screenHeight } = this.app.screen;
        this.wallWidth = screenWidth * this.scaleWidthArenaToScreen / this.colsCount;
        this.wallHeight = screenHeight * this.scaleHeightArenaToScreen / this.rowsCount;

        for (let rowIndex = 0; rowIndex &lt; this.rowsCount; rowIndex++) {
            for (let colIndex = 0; colIndex &lt; this.colsCount; colIndex++) {
                const { x, y, cellWidth, cellHeight } = this.gridToCanvas(colIndex, rowIndex);
                if (this.grid[rowIndex][colIndex].type === Arena.GRID_CELL_TYPE.WALL) {
                    let elem = new PIXI.Sprite(this.textures.wall);
                    elem.width = cellWidth;
                    elem.height = cellHeight;
                    elem.x = x;
                    elem.y = y;
                    this.grid[rowIndex][colIndex].elem = elem;
                    this.app.stage.addChild(elem);
                } else {
                    let elem = new PIXI.Graphics();
                    elem.rect(x, y, cellWidth, cellHeight);
                    elem.fill(HEX_COLOR_CODES.BLACK);
                    this.grid[rowIndex][colIndex].elem = elem;
                    this.app.stage.addChild(elem);
                }
            }
        }
    }

    /**
     * Redraws the arena on the screen.
     * Used when the screen is resized.
     */
    redraw() {
        const { width: screenWidth, height: screenHeight } = this.app.screen;
        this.wallWidth = screenWidth * this.scaleWidthArenaToScreen / this.colsCount;
        this.wallHeight = screenHeight * this.scaleHeightArenaToScreen / this.rowsCount;

        for (let rowIndex = 0; rowIndex &lt; this.rowsCount; rowIndex++) {
            for (let colIndex = 0; colIndex &lt; this.colsCount; colIndex++) {
                const { x, y, cellWidth, cellHeight } = this.gridToCanvas(colIndex, rowIndex);
                const elem = this.grid[rowIndex][colIndex].elem;
                elem.width = cellWidth;
                elem.height = cellHeight;
                elem.x = x;
                elem.y = y;
            }
        }
    }

    /**
     * Cleans up the arena.
     */
    cleanUp() {
        for (let row of this.grid) {
            for (let cell of row) {
                this.app.stage.removeChild(cell.elem);
            }
        }
        this.grid = null;
        this.wallWidth = null;
        this.wallHeight = null;
        this.wallsElements = null;
        this.freeSpaceElements = null;
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Arena.html">Arena</a></li><li><a href="Bomb_Bomb.html">Bomb</a></li><li><a href="BreakableWall_BreakableWall.html">BreakableWall</a></li><li><a href="EndGameDrawingManager.html">EndGameDrawingManager</a></li><li><a href="Enemy.html">Enemy</a></li><li><a href="Entity.html">Entity</a></li><li><a href="Explosion_Explosion.html">Explosion</a></li><li><a href="ExplosionInstance.html">ExplosionInstance</a></li><li><a href="Game.html">Game</a></li><li><a href="GameSessionManager.html">GameSessionManager</a></li><li><a href="GameSessionState.html">GameSessionState</a></li><li><a href="GameState.html">GameState</a></li><li><a href="MainMenuDrawingManager.html">MainMenuDrawingManager</a></li><li><a href="Player_Player.html">Player</a></li><li><a href="SettingsDrawingManager.html">SettingsDrawingManager</a></li><li><a href="SoundManager.html">SoundManager</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getBespokeRectText">getBespokeRectText</a></li><li><a href="global.html#getFontSize">getFontSize</a></li><li><a href="global.html#getProperDimensions">getProperDimensions</a></li><li><a href="global.html#getStringWithSafeMargin">getStringWithSafeMargin</a></li><li><a href="global.html#keyboard">keyboard</a></li><li><a href="global.html#loadAssetsManifest">loadAssetsManifest</a></li><li><a href="global.html#loadTextures">loadTextures</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#parseTime">parseTime</a></li><li><a href="global.html#PIXI_INIT_CONFIG">PIXI_INIT_CONFIG</a></li><li><a href="global.html#prepareAssets">prepareAssets</a></li><li><a href="global.html#prepareGameAssets">prepareGameAssets</a></li><li><a href="global.html#resizeCanvas">resizeCanvas</a></li><li><a href="global.html#setup">setup</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sun Jun 09 2024 19:21:47 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
